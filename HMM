HMM在分词上的运用原理详解 (原创)

假设有一句话S，由S1,S2,...Sn字组成，表示为：
S=S1S2S3...Sn
其分词结果可能有一下几种：
S=A1A2...AM
S=B1B2...BK
...
S=X1X2...XL

我们最终要求解的是分词分词可能性最大的一种情况，此处我们假设是第一种情况，即：
P(A1A2...An) > P(B1B2...Bn)
               ......
          > P(X1X2...Xn)

现在我们看一下下面信息通讯的过程：
      S1S2S3…    O1O2O3.... 
发送者-----信道------接收者
上述整个过程包含发送者、信道和接收者三个，S1S2S3…是发送的信号，O1O2O3....是解码的讯息，现在我们在知道解码的讯息的前提下求解S1S2S3…信号最大的可能性，即：
      P = max(P(S1S2S3…| O1O2O3...))
      此处我们将O1O2O3...想象为我们已知的某句话，S1S2S3…为分词组合,即已知某句话的前提下求解最大概率的分词组合。

下面我们来讲解求解过程：
根据贝叶斯公式，上式转化为：
      P = max(P(O1O2O3...| S1S2S3..)*P(S1S2S3..)/P(O1O2O3...))
      其中P(O1O2O3...),为已知的值（某句话），故我们求解最大的分词组合P可转化为求P(O1O2O3...| S1S2S3..)*P(S1S2S3..)最大，
      即，P1 = max(P(O1O2O3...| S1S2S3..)*P(S1S2S3..))，

为求解这个概率P1, 接下来我们讲解下分词的二元语法模型(又叫一阶马尔科夫链)和隐马尔科夫模型。
      二元语法模型：
	  还是对于句子S根据概率公式将P(S)展开：
	  P(S) = P(S1S2S3……) = P(S1)P(S2|S1)P(S3|S1S2)… =  ∏_(i=1)^n  P(s_i |s_1 s_2…s_(i-1))
	  此时，根据二元语法模型假设当前状态只与最相邻前一状态有关，可以想象一下今天的天气只与昨天有关一个道理，所以上式我们转化为：
	  P(S) = P(S1S2S3……) = P(S1)P(S2|S1)P(S3|S1S2)… ≈  ∏_(i=1)^n  P(s_i |s_(i-1))
	  关于二元模型的详解见：http://blog.csdn.net/firparks/article/details/54563683
	  
      隐马尔科夫模型：
	  关于隐马尔科夫模型看下图，其表示O1   O2  O3 分别只受S1  S2  S3  的影响，即：
P(O1O2O3| S1S2S3) = P(O1|S1) P(O2|S2) P(O3|S3)
	   
	  
现在我们回到上边P1 的概率求解过程：
P1 = max(P(O1O2O3...| S1S2S3..)*P(S1S2S3..)) 将其展开为：
P1 = ∏_(i=1)^n  P(O_i |S_i) ∏P(s_i |s_(i-1)) = P(S_1)∏_(i=1)^n  P(O_i |S_i) ∏_(i=2)^n P(s_i |s_(i-1))
此时，我们根据P(S_1)∏_(i=1)^n  P(O_i |S_i) ∏_(i=2)^n P(s_i |s_(i-1))来求解P1的值，其中P(S_1)为每个汉字是句首的概率，∏_(i=1)^n  P(O_i |S_i)为发射概率，∏_(i=2)^n P(s_i |s_(i-1))为转移概率，这些概率均可以通过语料库进行求解，其中转移概率使用viterbi算法进行求解。具体参看结巴分词源码。

Viterbi算法
def viterbi(obs, states, start_p, trans_p, emit_p):
    V = [{}]  # tabular
    path = {}
    for y in states:  # init
        V[0][y] = start_p[y] + emit_p[y].get(obs[0], MIN_FLOAT)
        path[y] = [y]
    for t in xrange(1, len(obs)):
        V.append({})
        newpath = {}
        for y in states:
            em_p = emit_p[y].get(obs[t], MIN_FLOAT)
            (prob, state) = max(
                [(V[t - 1][y0] + trans_p[y0].get(y, MIN_FLOAT) + em_p, y0) for y0 in PrevStatus[y]])
            V[t][y] = prob
            newpath[y] = path[state] + [y]
        path = newpath

    (prob, state) = max((V[len(obs) - 1][y], y) for y in 'ES')

    return (prob, path[state])
jieba分词源码种计算的P(S_1)概率：
P={'B': -0.26268660809250016,
 'E': -3.14e+100,
 'M': -3.14e+100,
 'S': -1.4652633398537678}
结巴源码计算的转移概率：
P={'B': {'E': -0.510825623765990, 'M': -0.916290731874155},
 'E': {'B': -0.5897149736854513, 'S': -0.8085250474669937},
 'M': {'E': -0.33344856811948514, 'M': -1.2603623820268226},
 'S': {'B': -0.7211965654669841, 'S': -0.6658631448798212}}

结巴源码计算的发射概率部分：
'B': {'\u4e00': -3.6544978750449433,
       '\u4e01': -8.125041941842026,
       '\u4e03': -7.817392401429855,
       '\u4e07': -6.3096425804013165,
       '\u4e08': -8.866689067453933,
       '\u4e09': -5.932085850549891,
       '\u4e0a': -5.739552583325728,
       '\u4e0b': -5.997089097239644,
       '\u4e0d': -4.274262055936421,
       '\u4e0e': -8.355569307500769,
       '\u4e10': -9.985251083961709,
       '\u4e11': -10.200388187382178,
       '\u4e13': -6.373950868459459,
       '\u4e14': -10.194028865473886
